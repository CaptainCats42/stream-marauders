<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Twitch Stream Raiders</title>
  <style>
    canvas { background: #222; display: block; margin: 1rem auto; border: 2px solid #444; }
    body { margin: 0; font-family: sans-serif; background: #111; color: white; text-align: center; }
    #leaderboard {
      margin-top: 1rem;
      background: #333;
      padding: 1rem;
      width: 300px;
      margin-left: auto;
      margin-right: auto;
      border-radius: 8px;
    }
    #leaderboard h2 { margin-top: 0; }
    #leaderboard ol { text-align: left; padding-left: 1.2rem; }
    #status {
      margin: 1rem;
      padding: 0.5rem;
      background: #444;
      border-radius: 4px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>Stream Marauders</h1>
  <p>Type <strong>!join</strong> to enter battle. Streamer: <span id="channelDisplay">captaincats42</span></p>
  <div id="status">Loading Twitch connection...</div>
  <canvas id="battlefield" width="800" height="400"></canvas>
  <div id="leaderboard">
    <h2>üèÜ Leaderboard</h2>
    <ol id="scores"></ol>
  </div>

  <script>
    const statusDiv = document.getElementById('status');
    
    function updateStatus(message, isError = false) {
      statusDiv.textContent = message;
      statusDiv.style.background = isError ? '#8B0000' : '#444';
    }

    function loadTmiAndStart() {
      if (typeof tmi === 'undefined') {
        updateStatus('Twitch library failed to load. Using demo mode.', true);
        startDemoMode();
        return;
      }

      updateStatus('Twitch connection loaded successfully!');

      const canvas = document.getElementById('battlefield');
      const ctx = canvas.getContext('2d');
      const units = [];
      let killCounts = {};
      let gameActive = false;

      const channel = 'captaincats42';
      const joinedUsers = new Set();

      class Unit {
        constructor(x, y, type, username = '', color = '') {
          this.x = x;
          this.y = y;
          this.type = type;
          this.username = username;
          this.hp = 100;
          this.speed = 1 + Math.random();
          this.damage = 10;
          this.color = color || (type === 'player' ? 'lime' : 'red');
          this.lastAttack = 0;
        }

        move() {
          this.x += this.type === 'player' ? this.speed : -this.speed;
        }

        draw() {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, 20, 20);
          ctx.fillStyle = '#fff';
          ctx.font = '10px Arial';
          ctx.fillText(this.hp, this.x, this.y - 5);
          if (this.username) ctx.fillText(this.username, this.x, this.y - 15);
        }
      }

      function spawnEnemy() {
        if (!gameActive || units.filter(u => u.type === 'enemy').length > 5) return;
        const y = Math.random() * (canvas.height - 20);
        units.push(new Unit(canvas.width - 30, y, 'enemy'));
      }

      function spawnPlayer(username, isSub = false) {
        const y = Math.random() * (canvas.height - 20);
        const color = isSub ? 'gold' : 'lime';
        units.push(new Unit(10, y, 'player', username, color));
      }

      function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let i = units.length - 1; i >= 0; i--) {
          const u = units[i];
          u.move();

          // Remove units that go off screen
          if (u.x < -30 || u.x > canvas.width + 30) {
            units.splice(i, 1);
            continue;
          }

          // Combat logic
          for (let j = units.length - 1; j >= 0; j--) {
            const other = units[j];
            if (u !== other && u.type !== other.type &&
                Math.abs(u.x - other.x) < 20 && Math.abs(u.y - other.y) < 20) {
              
              const now = Date.now();
              if (now - u.lastAttack > 500) { // Attack cooldown
                other.hp -= u.damage;
                u.lastAttack = now;
              }

              if (other.hp <= 0) {
                if (u.username && other.type === 'enemy') {
                  killCounts[u.username] = (killCounts[u.username] || 0) + 1;
                  updateLeaderboard();
                }
                units.splice(j, 1);
                if (j < i) i--; // Adjust index
              }
            }
          }

          if (i < units.length) u.draw();
        }
      }

      function updateLeaderboard() {
        const scores = Object.entries(killCounts).sort((a, b) => b[1] - a[1]);
        const list = document.getElementById('scores');
        list.innerHTML = '';
        scores.slice(0, 10).forEach(([user, kills]) => {
          const li = document.createElement('li');
          li.textContent = `${user}: ${kills}`;
          list.appendChild(li);
        });
      }

      setInterval(update, 1000 / 60);
      setInterval(spawnEnemy, 2000);
      updateLeaderboard();

      try {
        const client = new tmi.Client({ 
          channels: [channel],
          options: { debug: false }
        });
        
        client.connect().then(() => {
          updateStatus('Connected to Twitch chat! Type !join to play');
        }).catch(err => {
          console.error('TMI connection failed:', err);
          updateStatus('Failed to connect to Twitch chat. Demo mode active.', true);
          startDemoMode();
        });

        client.on('message', (channelName, tags, message, self) => {
          const username = tags.username.toLowerCase();
          const isSub = tags.subscriber || tags['badge-info']?.subscriber;
          const msg = message.trim().toLowerCase();

          if (msg === '!join' && !joinedUsers.has(username)) {
            joinedUsers.add(username);
            spawnPlayer(username, isSub);
            updateStatus(`${username} joined the battle!`);
          }

          if (msg === '!start' && (tags.mod || tags.username === channel)) {
            gameActive = true;
            updateStatus('Battle started! Enemies incoming!');
          }

          if (msg === '!clear' && (tags.mod || tags.username === channel)) {
            units.length = 0;
            joinedUsers.clear();
            killCounts = {};
            updateLeaderboard();
            gameActive = false;
            updateStatus('Battlefield cleared!');
          }
        });
      } catch (error) {
        console.error('Error initializing TMI client:', error);
        updateStatus('Error connecting to Twitch. Running in demo mode.', true);
        startDemoMode();
      }
    }

    function startDemoMode() {
      updateStatus('Demo Mode: Click canvas to spawn players!', false);
      
      const canvas = document.getElementById('battlefield');
      const ctx = canvas.getContext('2d');
      const units = [];
      let killCounts = {};
      let gameActive = true;

      const demoUsers = ['alice', 'bob', 'charlie', 'diana', 'eve'];

      class Unit {
        constructor(x, y, type, username = '', color = '') {
          this.x = x;
          this.y = y;
          this.type = type;
          this.username = username;
          this.hp = 100;
          this.speed = 1 + Math.random();
          this.damage = 10;
          this.color = color || (type === 'player' ? 'lime' : 'red');
          this.lastAttack = 0;
        }

        move() {
          this.x += this.type === 'player' ? this.speed : -this.speed;
        }

        draw() {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, 20, 20);
          ctx.fillStyle = '#fff';
          ctx.font = '10px Arial';
          ctx.fillText(this.hp, this.x, this.y - 5);
          if (this.username) ctx.fillText(this.username, this.x, this.y - 15);
        }
      }

      function spawnEnemy() {
        if (units.filter(u => u.type === 'enemy').length > 3) return;
        const y = Math.random() * (canvas.height - 20);
        units.push(new Unit(canvas.width - 30, y, 'enemy'));
      }

      function spawnPlayer() {
        const username = demoUsers[Math.floor(Math.random() * demoUsers.length)];
        const y = Math.random() * (canvas.height - 20);
        units.push(new Unit(10, y, 'player', username, 'lime'));
      }

      function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let i = units.length - 1; i >= 0; i--) {
          const u = units[i];
          u.move();

          if (u.x < -30 || u.x > canvas.width + 30) {
            units.splice(i, 1);
            continue;
          }

          for (let j = units.length - 1; j >= 0; j--) {
            const other = units[j];
            if (u !== other && u.type !== other.type &&
                Math.abs(u.x - other.x) < 20 && Math.abs(u.y - other.y) < 20) {
              
              const now = Date.now();
              if (now - u.lastAttack > 500) {
                other.hp -= u.damage;
                u.lastAttack = now;
              }

              if (other.hp <= 0) {
                if (u.username && other.type === 'enemy') {
                  killCounts[u.username] = (killCounts[u.username] || 0) + 1;
                  updateLeaderboard();
                }
                units.splice(j, 1);
                if (j < i) i--;
              }
            }
          }

          if (i < units.length) u.draw();
        }
      }

      function updateLeaderboard() {
        const scores = Object.entries(killCounts).sort((a, b) => b[1] - a[1]);
        const list = document.getElementById('scores');
        list.innerHTML = '';
        scores.slice(0, 10).forEach(([user, kills]) => {
          const li = document.createElement('li');
          li.textContent = `${user}: ${kills}`;
          list.appendChild(li);
        });
      }

      canvas.addEventListener('click', spawnPlayer);
      
      setInterval(update, 1000 / 60);
      setInterval(spawnEnemy, 3000);
      setInterval(spawnPlayer, 5000); // Auto spawn players in demo
      updateLeaderboard();
    }

    // Try multiple CDN sources for TMI.js
    const cdnSources = [
      "https://cdnjs.cloudflare.com/ajax/libs/tmi.js/1.8.5/tmi.min.js",
      "https://cdn.jsdelivr.net/npm/tmi.js@1.8.5/dist/tmi.min.js",
      "https://unpkg.com/tmi.js@1.8.5/dist/tmi.min.js"
    ];

    function tryLoadTmi(index = 0) {
      if (index >= cdnSources.length) {
        updateStatus('All CDN sources failed. Starting demo mode.', true);
        startDemoMode();
        return;
      }

      const script = document.createElement('script');
      script.src = cdnSources[index];
      script.onload = loadTmiAndStart;
      script.onerror = () => {
        console.warn(`Failed to load TMI from ${cdnSources[index]}`);
        tryLoadTmi(index + 1);
      };
      document.head.appendChild(script);
    }

    // Start loading
    tryLoadTmi();
  </script>
</body>
</html>
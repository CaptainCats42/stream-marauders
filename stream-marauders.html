<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Twitch Stream Raiders</title>
  <style>
    canvas { background: #222; display: block; margin: 1rem auto; border: 2px solid #444; }
    body { margin: 0; font-family: sans-serif; background: #111; color: white; text-align: center; }
    #leaderboard {
      margin-top: 1rem;
      background: #333;
      padding: 1rem;
      width: 300px;
      margin-left: auto;
      margin-right: auto;
      border-radius: 8px;
    }
    #leaderboard h2 { margin-top: 0; }
    #leaderboard ol { text-align: left; padding-left: 1.2rem; }
  </style>
</head>
<body>
  <h1>Stream Marauders</h1>
  <p>Type <strong>!join</strong> to enter battle. Streamer: <span id="channelDisplay">[loading]</span></p>
  <canvas id="battlefield" width="800" height="400"></canvas>
  <div id="leaderboard">
    <h2>üèÜ Leaderboard</h2>
    <ol id="scores"></ol>
  </div>

  <script>
    function loadScript(src, callback) {
      const script = document.createElement('script');
      script.src = src;
      script.onload = callback;
      script.onerror = () => alert("Failed to load Twitch library. Check your internet connection or CDN availability.");
      document.head.appendChild(script);
    }

    loadScript("https://cdn.jsdelivr.net/npm/tmi.js@1.8.5/dist/tmi.min.js", function () {
      const canvas = document.getElementById('battlefield');
      const ctx = canvas.getContext('2d');
      const units = [];
      let killCounts = JSON.parse(localStorage.getItem('killCounts')) || {};
      let gameActive = false;

      const channel = 'captaincats42'.toLowerCase();
      document.getElementById('channelDisplay').textContent = channel;

      class Unit {
        constructor(x, y, type, username = '', color = '') {
          this.x = x;
          this.y = y;
          this.type = type;
          this.username = username;
          this.hp = 100;
          this.speed = 1 + Math.random();
          this.damage = 10;
          this.color = color || (type === 'player' ? 'lime' : 'red');
        }

        move() {
          this.x += this.type === 'player' ? this.speed : -this.speed;
        }

        draw() {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, 20, 20);

          ctx.fillStyle = '#fff';
          ctx.font = '10px Arial';
          ctx.fillText(this.hp, this.x, this.y - 5);
          if (this.username) {
            ctx.fillText(this.username, this.x, this.y - 15);
          }
        }
      }

      function spawnEnemy() {
        if (!gameActive) return;
        const y = Math.random() * (canvas.height - 20);
        units.push(new Unit(canvas.width - 30, y, 'enemy'));
      }

      function spawnPlayer(username, isSub = false) {
        const y = Math.random() * (canvas.height - 20);
        const color = isSub ? 'gold' : 'lime';
        units.push(new Unit(10, y, 'player', username, color));
      }

      function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let i = units.length - 1; i >= 0; i--) {
          const u = units[i];
          u.move();

          for (let j = units.length - 1; j >= 0; j--) {
            const other = units[j];
            if (u !== other && u.type !== other.type &&
                Math.abs(u.x - other.x) < 20 && Math.abs(u.y - other.y) < 20) {
              other.hp -= u.damage;
              u.hp -= other.damage;

              if (other.hp <= 0) {
                if (u.username) {
                  killCounts[u.username] = (killCounts[u.username] || 0) + 1;
                  localStorage.setItem('killCounts', JSON.stringify(killCounts));
                  updateLeaderboard();
                }
                units.splice(j, 1);
              }
              if (u.hp <= 0) {
                units.splice(i, 1);
                break;
              }
            }
          }

          u.draw();
        }
      }

      function updateLeaderboard() {
        const scores = Object.entries(killCounts).sort((a, b) => b[1] - a[1]);
        const list = document.getElementById('scores');
        list.innerHTML = '';
        scores.forEach(([user, kills]) => {
          const li = document.createElement('li');
          li.textContent = `${user}: ${kills}`;
          list.appendChild(li);
        });
      }

      setInterval(update, 1000 / 60);
      setInterval(spawnEnemy, 3000);

      const joinedUsers = new Set();
      const client = new tmi.Client({ channels: [channel] });
      client.connect().catch(console.error);

      client.on('message', (channelName, tags, message, self) => {
        const username = tags.username.toLowerCase();
        const isSub = tags.subscriber || tags['badge-info']?.subscriber;
        const msg = message.trim().toLowerCase();

        if (msg === '!join' && !joinedUsers.has(username)) {
          joinedUsers.add(username);
          spawnPlayer(username, isSub);
        }

        if (msg === '!start' && (tags.mod || tags.username === channel)) {
          gameActive = true;
        }

        if (msg === '!clear' && (tags.mod || tags.username === channel)) {
          units.length = 0;
          joinedUsers.clear();
          killCounts = {};
          localStorage.setItem('killCounts', JSON.stringify(killCounts));
          updateLeaderboard();
          gameActive = false;
        }
      });

      updateLeaderboard();
    });
  </script>
</body>
</html>
